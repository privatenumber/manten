var me=Object.defineProperty;var i=(e,t)=>me(e,"name",{value:t,configurable:!0});import{setMaxListeners as pe}from"node:events";import{inspect as ge,isDeepStrictEqual as ye,format as be}from"node:util";import F from"node:path";import I from"node:fs";import U from"node:os";import{expect as ct}from"expect";let b=!0;const w=typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{};let T=0;if(w.process&&w.process.env&&w.process.stdout){const{FORCE_COLOR:e,NODE_DISABLE_COLORS:t,NO_COLOR:s,TERM:r,COLORTERM:o}=w.process.env;t||s||e==="0"?b=!1:e==="1"||e==="2"||e==="3"?b=!0:r==="dumb"?b=!1:"CI"in w.process.env&&["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE","DRONE"].some(n=>n in w.process.env)?b=!0:b=process.stdout.isTTY,b&&(process.platform==="win32"||o&&(o==="truecolor"||o==="24bit")?T=3:r&&(r.endsWith("-256color")||r.endsWith("256"))?T=2:T=1)}let Y={enabled:b,supportLevel:T};function E(e,t,s=1){const r=`\x1B[${e}m`,o=`\x1B[${t}m`,n=new RegExp(`\\x1b\\[${t}m`,"g");return f=>Y.enabled&&Y.supportLevel>=s?r+(""+f).replace(n,r)+o:""+f}i(E,"kolorist");const g=E(2,22),R=E(31,39),C=E(32,39),K=E(33,39),W=i(e=>Number.isFinite(e)?e:0,"toZeroIfInfinity");function Se(e){return{days:Math.trunc(e/864e5),hours:Math.trunc(e/36e5%24),minutes:Math.trunc(e/6e4%60),seconds:Math.trunc(e/1e3%60),milliseconds:Math.trunc(e%1e3),microseconds:Math.trunc(W(e*1e3)%1e3),nanoseconds:Math.trunc(W(e*1e6)%1e3)}}i(Se,"parseNumber");function we(e){return{days:e/86400000n,hours:e/3600000n%24n,minutes:e/60000n%60n,seconds:e/1000n%60n,milliseconds:e%1000n,microseconds:0n,nanoseconds:0n}}i(we,"parseBigint");function Te(e){switch(typeof e){case"number":{if(Number.isFinite(e))return Se(e);break}case"bigint":return we(e)}throw new TypeError("Expected a finite number or bigint")}i(Te,"parseMilliseconds");const $e=i(e=>e===0||e===0n,"isZero"),Ee=i((e,t)=>t===1||t===1n?e:`${e}s`,"pluralize"),ke=1e-7,De=24n*60n*60n*1000n;function P(e,t){const s=typeof e=="bigint";if(!s&&!Number.isFinite(e))throw new TypeError("Expected a finite number or bigint");t={...t};const r=e<0?"-":"";e=e<0?-e:e,t.colonNotation&&(t.compact=!1,t.formatSubMilliseconds=!1,t.separateMilliseconds=!1,t.verbose=!1),t.compact&&(t.unitCount=1,t.secondsDecimalDigits=0,t.millisecondsDecimalDigits=0);let o=[];const n=i((l,h)=>{const p=Math.floor(l*10**h+ke);return(Math.round(p)/10**h).toFixed(h)},"floorDecimals"),f=i((l,h,p,d)=>{if(!((o.length===0||!t.colonNotation)&&$e(l)&&!(t.colonNotation&&p==="m"))){if(d??=String(l),t.colonNotation){const S=d.includes(".")?d.split(".")[0].length:d.length,$=o.length>0?2:1;d="0".repeat(Math.max(0,$-S))+d}else d+=t.verbose?" "+Ee(h,l):p;o.push(d)}},"add"),c=Te(e),a=BigInt(c.days);if(t.hideYearAndDays?f(BigInt(a)*24n+BigInt(c.hours),"hour","h"):(t.hideYear?f(a,"day","d"):(f(a/365n,"year","y"),f(a%365n,"day","d")),f(Number(c.hours),"hour","h")),f(Number(c.minutes),"minute","m"),!t.hideSeconds)if(t.separateMilliseconds||t.formatSubMilliseconds||!t.colonNotation&&e<1e3&&!t.subSecondsAsDecimals){const l=Number(c.seconds),h=Number(c.milliseconds),p=Number(c.microseconds),d=Number(c.nanoseconds);if(f(l,"second","s"),t.formatSubMilliseconds)f(h,"millisecond","ms"),f(p,"microsecond","\xB5s"),f(d,"nanosecond","ns");else{const S=h+p/1e3+d/1e6,$=typeof t.millisecondsDecimalDigits=="number"?t.millisecondsDecimalDigits:0,he=S>=1?Math.round(S):Math.ceil(S),J=$?S.toFixed($):he;f(Number.parseFloat(J),"millisecond","ms",J)}}else{const l=(s?Number(e%De):e)/1e3%60,h=typeof t.secondsDecimalDigits=="number"?t.secondsDecimalDigits:1,p=n(l,h),d=t.keepDecimalsOnWholeSeconds?p:p.replace(/\.0+$/,"");f(Number.parseFloat(d),"second","s",d)}if(o.length===0)return r+"0"+(t.verbose?" milliseconds":"ms");const u=t.colonNotation?":":" ";return typeof t.unitCount=="number"&&(o=o.slice(0,Math.max(t.unitCount,1))),r+o.join(u)}i(P,"prettyMilliseconds");const y=`
`,Ne="    ",{log:M,error:k}=console,Le=C("\u2714"),Ae=R("\u2716"),Fe=K("\u2022"),Ie=g("\u25CB"),O=i(()=>{const e=new Date,t=String(e.getHours()).padStart(2,"0"),s=String(e.getMinutes()).padStart(2,"0"),r=String(e.getSeconds()).padStart(2,"0");return g(`${t}:${s}:${r}`)},"formatTimestamp"),G=i(({startTime:e,timeout:t,endTime:s})=>{const r=(s||Date.now())-e;let o=P(r);return t&&(o+=` / ${P(t)}`),r<50?"":` ${g(`(${o})`)}`},"prettyDuration"),Re=i(e=>e.replaceAll(/^/gm,Ne),"indentMultiline"),j=i((e,t=!0)=>{const{title:s,attempt:r,retry:o}=e;let n=`${s+G(e)}`;return t&&o>1&&(n+=g(` (${r}/${o})`)),n},"getTestTitle"),_=i((e,t,s)=>{let r=`${O()} ${Ae} ${j(e)}`;s&&(r+=` [${s}]`),k(r),k(`${Re(ge(t))}
`)},"logTestFail"),Pe=i(e=>{M(`${O()} ${Le} ${j(e)}`)},"logTestSuccess"),Z=i(e=>{M(`${O()} ${Ie} ${j(e,!1)}`)},"logTestSkip"),Me=i(e=>{if(e.length===0)return;const t=[];let s=0,r=0,o=0,n,f;for(const a of e)a.startTime&&(!n||n>a.startTime)&&(n=a.startTime),a.endTime===void 0?t.push(a):((!f||f<a.endTime)&&(f=a.endTime),a.error?r+=1:a.skip?o+=1:s+=1);let c="";if(t.length>0){for(const a of t)c+=`${y}${Fe} ${a.title+G(a)}`;c+=y}c+=`${y}${g(P((f??Date.now())-n))}`,c+=y+(s>0?C:g)(`${s.toLocaleString()} passed`),r>0&&(c+=y+R(`${r.toLocaleString()} failed`)),o>0&&(c+=y+g(`${o.toLocaleString()} skipped`)),t.length>0&&(c+=y+K(`${t.length.toLocaleString()} pending`)),c+=y,M(c)},"logReport"),Oe=i(()=>{let e,t;const s=new Promise((r,o)=>{e=r,t=o});return Object.assign(s,{resolve:e,reject:t})},"createDeferred"),je=i((e,t)=>{const s=Oe(),r=setTimeout(()=>{const o=new Error(`Timeout: ${e}ms`);t?.abort(o),s.reject(o)},e);return Object.assign(s,{timeoutId:r})},"setTimer"),v=i((e,t,s)=>{if(!e||!("then"in e)||t===void 0||t===0)return e;const r=je(t,s);return Promise.race([e,r]).finally(()=>{clearTimeout(r.timeoutId)})},"timeLimitFunction"),Q=i(e=>{const t=[];return{addHook:i(o=>{t.push(o)},"addHook"),runHooks:i(async(...o)=>{for(const n of t)try{await n(...o)}catch(f){await e(f)}},"runHooks")}},"createHook"),_e=i(async(e,t)=>{for(let s=1;s<=t;s+=1)try{await e(s);return}catch(r){if(s===t)throw r}},"retry"),He=i((e,t)=>{if(t instanceof Map)return{$type:"Map",entries:Array.from(t.entries()).sort(([s],[r])=>{const o=String(s),n=String(r);return o<n?-1:o>n?1:0})};if(t instanceof Set)return{$type:"Set",values:Array.from(t).sort((s,r)=>{const o=String(s),n=String(r);return o<n?-1:o>n?1:0})};if(typeof t=="bigint")return`${t}n`;if(t===void 0)return"$undefined";if(typeof t=="function")return`[Function: ${t.name||"anonymous"}]`;if(typeof t=="symbol"||t instanceof RegExp)return t.toString();if(t instanceof Date)return t.toISOString();if(t instanceof Error)return{$type:"Error",name:t.name,message:t.message,stack:t.stack?.split(`
`)[0]||""};if(t instanceof Uint8Array)return{$type:t.constructor.name,data:Array.from(t)};if(t&&typeof t=="object"){const s=Object.prototype.toString.call(t);if(s!=="[object Object]"&&s!=="[object Array]"&&s!=="[object Date]"&&s!=="[object RegExp]"&&s!=="[object Error]")return s}return t},"snapshotReplacer"),H=i((e,t=new Set)=>{if(!e||typeof e!="object"||e instanceof Date||e instanceof RegExp||e instanceof Error||e instanceof Map||e instanceof Set||e instanceof Uint8Array)return e;if(t.has(e))return"[Circular]";if(t.add(e),Array.isArray(e)){const o=Array.from({length:e.length});for(let n=0;n<e.length;n+=1)n in e&&(o[n]=H(e[n],t));return t.delete(e),o}const s={},r=Object.keys(e).sort();for(const o of r)s[o]=H(e[o],t);return t.delete(e),s},"sortObjectKeys"),Be=i(e=>{try{const t=H(e),s=JSON.stringify(t,He);return JSON.parse(s)}catch(t){return t instanceof Error&&t.message.includes("circular")?"[Circular Reference]":`[Serialization Error: ${t}]`}},"serializeValue"),xe=i(e=>{const t=Array.from(e.keys()).sort(),s={};for(const r of t)s[r]=e.get(r);return JSON.stringify(s,null,2)},"formatSnapshotFile"),ze=i(e=>{if(e.length===0)return"";const t={new:0,updated:0,passed:0,failed:0};for(const{summary:r}of e)t.new+=r.new,t.updated+=r.updated,t.passed+=r.passed,t.failed+=r.failed;const s=[];return t.new>0&&s.push(`\u{1F4F8} ${t.new} new`),t.updated>0&&s.push(`\u270F\uFE0F ${t.updated} updated`),t.passed>0&&s.push(`\u2705 ${t.passed} passed`),t.failed>0&&s.push(`\u274C ${t.failed} failed`),s.length>0?`
Snapshots: ${s.join(", ")}`:""},"formatSnapshotSummary");let m;const D=new Set,N=new Set,B=new Set,x=new Set,L=new Map,qe=new Set,X=new Map;let ee=!1,z=process.env.MANTEN_SNAPSHOT_PATH||".manten.snap";const Ve=process.env.MANTEN_UPDATE_SNAPSHOTS==="1"||process.env.MANTEN_UPDATE_SNAPSHOTS==="true",Je=i(()=>{if(m===void 0)try{const e=F.resolve(z),t=I.readFileSync(e,"utf8"),s=JSON.parse(t);m=new Map;for(const r in s)m.set(r,s[r])}catch{m=new Map}},"loadSnapshots"),Ue=i((e,t,s,r)=>{m===void 0&&Je();const o=X.get(e);if(o!==void 0&&o!==r)throw new Error(`Duplicate test title detected: "${e}". Test titles must be unique across all files when using global snapshots.`);L.has(e)||(L.set(e,0),X.set(e,r),qe.add(e));let n;if(s)n=s;else{const a=L.get(e)+1;L.set(e,a),n=`${e} ${a}`}if(D.has(n)||N.has(n)||x.has(n)||B.has(n))throw new Error(`Duplicate snapshot key: "${n}". Test names must be unique across all test files.`);const f=Be(t);if(!m.has(n)){m.set(n,f),D.add(n);return}const c=m.get(n);if(ye(f,c))x.add(n);else if(Ve)m.set(n,f),N.add(n);else throw B.add(n),new Error(`Snapshot mismatch for "${n}"
Expected: ${te(c)}
Received: ${te(f)}`)},"matchSnapshot"),te=i(e=>be("%O",e),"format"),Ye=i(()=>{if(D.size===0&&N.size===0||!m)return;const e=F.resolve(z),t=F.dirname(e);ee||(I.mkdirSync(t,{recursive:!0}),ee=!0);const s=xe(m);I.writeFileSync(e,s,"utf8")},"saveSnapshots"),Ce=i(()=>({new:D.size,updated:N.size,failed:B.size,passed:x.size}),"getSummary");process.on("exit",()=>{try{Ye();const e=Ce();if(e.new>0||e.updated>0||e.passed>0||e.failed>0){const t=ze([{file:"global",summary:e}]);t&&process.stdout.write(`${t}
`)}}catch(e){process.stderr.write(`Failed to save snapshots: ${e}
`)}});const Ke=i(e=>{if(e.snapshotPath!==void 0&&m!==void 0)throw new Error("configure() must be called before any snapshot tests are run. Snapshots have already been loaded from the default location. Please ensure configure() is called at the beginning of your test suite.");e.snapshotPath!==void 0&&(z=e.snapshotPath)},"configure");class se extends Error{static{i(this,"SkipError")}constructor(t){super(t||"Test skipped"),this.name="SkipError"}}const ne=i(e=>(e&&typeof e=="object"&&"matcherResult"in e&&e.constructor.name==="JestAssertionError"&&delete e.matcherResult,e),"patchJestAssertionError"),re=i(async(e,t)=>{const{testFunction:s,timeout:r}=e,o=Q(c=>{_(e,c,"onTestFail")}),n=i(async c=>{await o.runHooks(c)},"handleError"),f=Q(async c=>{_(e,ne(c),"onTestFinish")});try{await _e(async c=>{e.attempt=c,e.startTime=Date.now();const a=new AbortController;let u;t&&(u=i(()=>{a.signal.aborted||a.abort(t.abortController.signal.reason)},"handleParentAbort"),t.abortController.signal.addEventListener("abort",u),t.abortController.signal.aborted&&u());try{await v(s({signal:a.signal,onTestFail:o.addHook,onTestFinish:f.addHook,skip:i(l=>{throw new se(l)},"skip"),expectSnapshot:i((l,h)=>{Ue(e.title,l,h,e)},"expectSnapshot")}),r,a),Pe(e)}catch(l){if(l instanceof se)e.skip=!0,Z(e);else throw _(e,ne(l)),await n(l),l}finally{t&&u&&t.abortController.signal.removeEventListener("abort",u),a.signal.aborted||a.abort(),await f.runHooks(),e.endTime=Date.now()}},e.retry)}catch(c){e.error=c,process.exitCode=1}},"runTest"),oe=[];process.on("exit",()=>{Me(oe)});const A=process.env.TESTONLY;A&&console.log(g(`Only running tests that match: ${JSON.stringify(A)}
`));const ie=i((e,t)=>((s,r,o)=>{if(e&&(s=`${e} ${s}`),t&&(t.testsStarted=!0),A&&!s.includes(A))return Promise.resolve();const n={title:s,testFunction:r,retry:1};if(o!==void 0&&(typeof o=="number"?n.timeout=o:(n.timeout=o?.timeout,o?.retry&&(n.retry=o?.retry))),oe.push(n),t?.skipped){n.skip=!0,n.skipReason=t.skipReason;const f=Date.now();return n.startTime=f,n.endTime=f,Z(n),Promise.resolve()}return(async()=>{const c=i(async()=>{if(t?.concurrencyLimiter){const a=await t.concurrencyLimiter.acquire();try{await re(n,t)}finally{a()}}else await re(n,t)},"executeTest")();t&&t.pendingTests.push(c),await c})()}),"createTest"),We=i(async e=>{for(;e.length>0;){const t=e.splice(0);await Promise.all(t)}},"waitAllPromises"),Ge=i(e=>("default"in e&&(e=e.default),"default"in e&&(e=e.default),e),"unwrapModule"),q=i(e=>{let t=typeof e=="number"?e:ce(),s=0;const r=[];let o;return e==="auto"&&(o=setInterval(()=>{const a=ce();if(a!==t)for(t=a;r.length>0&&s<t;){const u=r.shift();u&&(s+=1,u())}},5e3),o.unref()),{acquire:i(()=>s<t?(s+=1,Promise.resolve(()=>{s-=1;const a=r.shift();a&&(s+=1,a())})):new Promise(a=>{r.push(()=>{a(()=>{s-=1;const u=r.shift();u&&(s+=1,u())})})}),"acquire"),setLimit:i(a=>{for(t=a;r.length>0&&s<t;){const u=r.shift();u&&(s+=1,u())}},"setLimit"),cleanup:i(()=>{o&&clearInterval(o)},"cleanup")}},"createSemaphore"),ce=i(()=>{const e=U.cpus().length,t=U.loadavg()[0];return Math.max(1,Math.min(Math.floor(e*(1-Math.min(t/e,.8))),e))},"calculateAutoLimit"),ae=i((e,t)=>((s,r,o)=>(e&&(s=`${e} ${s}`),t&&(t.testsStarted=!0),(async()=>{const n=V(s,o?.parallel,o?.timeout);await i(async()=>{if(t?.concurrencyLimiter){const c=await t.concurrencyLimiter.acquire();try{await n.run(r,t)}finally{c()}}else await n.run(r,t)},"executeDescribe")()})())),"createDescribe"),fe=i((e,t)=>((s,...r)=>{t&&(t.testsStarted=!0);const o=i(()=>{const n=V(e);return n.run(async()=>Ge(await s).apply(n,r),t)},"executeTestSuite");return t?.concurrencyLimiter?t.concurrencyLimiter.acquire().then(n=>o().finally(n)):o()}),"createRunTestSuite"),ue=ie(),le=ae(),de=fe(),V=i((e,t,s)=>{let r;t!==void 0&&(t===!0?r=void 0:t===!1?r=q(1):typeof t=="number"?r=q(t):t==="auto"&&(r=q("auto")));const o=new AbortController;pe(0,o.signal);const n={pendingTests:[],callbacks:{onFinish:[]},concurrencyLimiter:r,abortController:o,timeout:s,skipped:!1,skipReason:void 0,testsStarted:!1,run:i(async(f,c)=>{c?.skipped&&(n.skipped=!0,n.skipReason=c.skipReason);let a;c&&(a=i(()=>{o.signal.aborted||o.abort(c.abortController.signal.reason)},"handleParentAbort"),c.abortController.signal.addEventListener("abort",a),c.abortController.signal.aborted&&a());try{const u=(async()=>{await f(n.api),await We(n.pendingTests)})();c&&c.pendingTests.push(u),await v(u,s,o)}catch(u){k(u),process.exitCode=1}finally{c&&a&&c.abortController.signal.removeEventListener("abort",a),o.signal.aborted||o.abort(),r&&r.cleanup();for(const u of n.callbacks.onFinish)try{await u()}catch(l){k(l),process.exitCode=1}}},"run")};return n.api={signal:o.signal,test:e?ie(`${e} \u203A`,n):ue,describe:e?ae(`${e} \u203A`,n):le,runTestSuite:e?fe(e,n):de,onFinish:i(f=>{n.callbacks.onFinish.push(f)},"onFinish"),skip:i(f=>{if(n.testsStarted)throw new Error("skip() must be called before any tests or nested describes run. Move skip() to the beginning of the describe callback.");n.skipped=!0,n.skipReason=f},"skip")},n},"createContext"),Ze=V(),ve=i((e,t,s)=>{const r=typeof e=="string"?e:void 0,o=typeof e=="string"?t:e,n=typeof e=="string"?s:void 0;return i(async function(...c){const a=this||Ze;r?await a.api.describe(r,u=>o(u,...c),n):await o(a.api,...c)},"testSuiteWrapper")},"testSuite"),Qe=i(e=>{setTimeout(()=>{process.exitCode=1,console.error(R(`\u2716 Process timed out after ${e}ms`)),setImmediate(()=>process.exit(1))},e).unref()},"setProcessTimeout");export{Ke as configure,le as describe,ct as expect,de as runTestSuite,Qe as setProcessTimeout,ue as test,ve as testSuite};
